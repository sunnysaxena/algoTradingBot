"""
Base Strategy Class for Algorithmic Trading

This serves as an abstract base class for implementing various trading strategies.
It provides core functionality like:
- Strategy execution framework.
- Backtesting logic.
- Signal-based trading logic.
- Support for dynamic selection of technical analysis libraries (`talib` or `pandas_ta`).

Key Features:
- **Abstract Class**: Requires subclasses to implement `apply_strategy()`.
- **Dynamic Indicator Library Loading**: Supports `talib` and `pandas_ta` for technical indicators.
- **Backtesting Engine**: Simulates strategy performance with capital management.
- **Performance Visualization**: Plots buy/sell signals and cumulative returns.

Usage:
- Inherit from `BaseStrategy` and implement the `apply_strategy()` method.
- Use `self.library` to apply indicators dynamically.
- Call `backtest()` to evaluate strategy performance.
- Use `plot_results()` to visualize strategy effectiveness.
"""

import numpy as np
import matplotlib.pyplot as plt
from abc import ABC, abstractmethod

class BaseStrategy(ABC):
    """
    Abstract Base Class for Trading Strategies.

    Attributes:
        df (pd.DataFrame): Market data containing OHLC prices.
        strategy_params (dict): Configuration dictionary containing strategy-specific parameters.
        signals (pd.DataFrame): Stores buy/sell signals generated by the strategy.
        library (module): The technical analysis library (`talib` or `pandas_ta`).
    """
    def __init__(self, df, strategy_params, library="talib"):
        """
        Initializes the base strategy.

        Parameters:
            df (pd.DataFrame): Market data with OHLC prices.
            strategy_params (dict): Dictionary containing strategy parameters.
            library (str): The technical analysis library to use ('talib' or 'pandas_ta').
        """
        self.df = df
        self.strategy_params = strategy_params
        self.signals = None
        self.library = self._load_library(library)

    def _load_library(self, library_name):
        """
        Dynamically loads the selected technical analysis library.

        Parameters:
            library_name (str): The library to use ('talib' or 'pandas_ta').

        Returns:
            module: The imported library module.

        Raises:
            ValueError: If an unsupported library name is provided.
        """

        if library_name == "talib":
            import talib
            return talib
        elif library_name == "pandas_ta":
            import pandas_ta as ta
            return ta
        else:
            raise ValueError(f"Unsupported library: {library_name}")

    @abstractmethod
    def apply_strategy(self):
        """
            Abstract method to be implemented by subclasses.
            Defines the logic for generating buy/sell signals.
        """
        pass

    def backtest(self, initial_capital=100000, commission=0.001, slippage=0.0005):
        """
        Simulates the strategy’s performance using historical data.

        Parameters:
            initial_capital (float): Starting capital for backtesting.
            commission (float): Commission cost per trade.
            slippage (float): Slippage cost per trade.

        Returns:
            pd.DataFrame: DataFrame with strategy returns and cumulative performance.
        """
        self.df["returns"] = self.df["close"].pct_change()
        self.df["strategy_returns"] = self.df["returns"] * self.signals["signal"].shift(1)

        # Apply transaction costs
        self.df["strategy_returns"] -= (commission + slippage)

        # Compute cumulative returns
        self.df["cumulative_returns"] = (1 + self.df["strategy_returns"]).cumprod() * initial_capital

        return self.df

    def plot_results(self):
        """
        Plots the strategy’s buy/sell signals and cumulative returns.
        """
        fig, ax = plt.subplots(2, 1, figsize=(12, 8))

        # Price & Buy/Sell Signals
        ax[0].plot(self.df.index, self.df["close"], label="Close Price", color="black", linewidth=1)
        buy_signals = self.df[self.signals["signal"] == 1]
        sell_signals = self.df[self.signals["signal"] == -1]
        ax[0].scatter(buy_signals.index, buy_signals["close"], label="Buy Signal", marker="^", color="green")
        ax[0].scatter(sell_signals.index, sell_signals["close"], label="Sell Signal", marker="v", color="red")
        ax[0].set_title("Entry & Exit Points")
        ax[0].legend()

        # Cumulative Returns
        ax[1].plot(self.df.index, self.df["cumulative_returns"], label="Cumulative Returns", color="blue")
        ax[1].set_title("Portfolio Performance")
        ax[1].legend()

        plt.tight_layout()
        plt.show()
